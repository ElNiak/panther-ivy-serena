---
name: RFC-to-Ivy Mapping
description: This skill should be used when the user asks about "translating RFC", "requirements extraction", "specification mapping", "RFC to Ivy", "mapping MUST SHOULD MAY", "formalizing RFC requirements", "extracting protocol requirements", or mentions converting natural language RFC requirements into formal Ivy specifications in the PANTHER framework.
---

# RFC-to-Ivy Mapping

## Overview

Translating RFC requirements into formal Ivy specifications is the foundational step of NCT/NACT methodology. This skill provides a systematic approach to reading RFC normative language, identifying testable properties, and mapping them to Ivy constructs (invariants, monitors, actions).

## RFC Normative Language

RFC 2119 defines key requirement levels:

| Keyword | Meaning | Testability |
|---|---|---|
| **MUST** / **MUST NOT** | Absolute requirement/prohibition | Directly testable — map to `require` assertions |
| **SHOULD** / **SHOULD NOT** | Recommended/not recommended | Testable with weaker assertions or warnings |
| **MAY** | Optional behavior | Not directly testable — test that handling is correct when present |

### Extracting Requirements

1. Read the RFC section by section
2. Identify every MUST, MUST NOT, SHOULD, SHOULD NOT, MAY statement
3. Classify each requirement by protocol layer (frame, packet, connection, etc.)
4. Determine which requirements are testable via network observation
5. Note requirements that need internal state (harder to test externally)

Reference: `protocol-testing/quic/new_requirements_rfc9000.txt` shows extracted QUIC requirements with annotations.

## Mapping Patterns

### MUST → require in before/after

RFC requirement:
> "A server MUST NOT send data in excess of either limit."

Ivy mapping (in behavior file):
```ivy
after frame.stream.handle(f) {
    require f.offset + f.length <= max_stream_data(f.stream_id);
    require total_data_sent <= max_data;
}
```

### MUST NOT → require negation

RFC requirement:
> "An endpoint MUST NOT send a MAX_STREAMS frame with a value greater than 2^60."

Ivy mapping:
```ivy
before frame.max_streams.handle(f) {
    require f.max_streams <= 0x1000000000000000;
}
```

### Connection MUST be closed → error handling

RFC requirement:
> "If a max_streams transport parameter is received with a value greater than 2^60, the connection MUST be closed immediately with TRANSPORT_PARAMETER_ERROR."

Ivy mapping:
```ivy
after transport_parameter_event(src, dst, tp) {
    if tp.max_streams > 0x1000000000000000 {
        require connection_error(the_cid) = transport_parameter_error;
    }
}
```

### State transitions → before guards

RFC requirement:
> "A client MUST NOT send a Handshake packet before receiving the server's Initial packet."

Ivy mapping:
```ivy
before packet_event(src, dst, pkt) {
    if pkt.hdr.ptype = handshake & is_client(src) {
        require server_initial_received(the_cid);
    }
}
```

### Counting/ordering → after state updates

RFC requirement:
> "ACK frames MUST acknowledge the most recently received packet."

Ivy mapping:
```ivy
after frame.ack.handle(f) {
    require f.largest_acknowledged >= last_received_pkt_num(the_cid);
    conn_ack_count(the_cid) := conn_ack_count(the_cid) + 1;
}
```

### _finalize checks → end-state properties

RFC requirement:
> "The handshake MUST complete successfully before application data is sent."

Ivy mapping:
```ivy
export action _finalize = {
    require handshake_completed(the_cid);
    require is_no_error;
    require conn_total_data(the_cid) > 0;
}
```

## Ivy Constructs Reference

| Ivy Construct | Use For | Example |
|---|---|---|
| `require` | Assertions that must hold (MUST/MUST NOT) | `require pkt.version = negotiated_version;` |
| `before action(...)` | Preconditions before an event | Guards, state checks |
| `after action(...)` | Postconditions/updates after an event | State updates, compliance checks |
| `invariant` | Properties that always hold | `invariant conn_state(C) ~= closed -> has_cid(C)` |
| `relation` | Boolean state variables | `relation connected(cid)` |
| `function` | State variables with return type | `function conn_state(cid) : connection_state` |
| `action` | Protocol events | `action packet_event(src:endpoint, dst:endpoint, pkt:packet)` |
| `export` | Actions generated by test mirror | `export frame.stream.handle` |
| `import` | Actions provided by implementation | `import action send_packet` |

## Systematic Mapping Workflow

### Step 1: Extract Requirements
Read the RFC and list all normative statements. Use the format:
```
Section X.Y: "Exact RFC text" [MUST|SHOULD|MAY] -> Layer: {layer_name}
```

### Step 2: Classify by Layer
Group requirements by which 14-layer template layer they belong to:
- Type/encoding requirements → types, frame, packet layers
- Behavioral requirements → entity behavior layer
- State machine requirements → connection, FSM layers
- Security requirements → security, protection layers
- Error handling requirements → error_code layer

### Step 3: Identify Testable Properties
Determine which requirements can be tested via network observation:
- **Directly testable**: Packet format, frame content, error responses
- **Indirectly testable**: Internal state inferred from external behavior
- **Not testable**: Timing requirements, performance characteristics (use NSCT for some)

### Step 4: Write Ivy Assertions
For each testable requirement, write the appropriate Ivy construct:
1. Determine if it is a precondition (before) or postcondition (after)
2. Identify which action/event it applies to
3. Express the requirement as a `require` statement
4. Add state variable updates if needed for tracking

### Step 5: Verify Consistency
Use `mcp__plugin_panther-ivy-plugin_panther-serena__ivy_check` to verify that the assertions are internally consistent and do not contradict each other.

## Common Pitfalls

### Ambiguous RFC Language
Some RFC statements are ambiguous. When in doubt:
- Check the RFC errata for clarifications
- Look at how existing models handle similar requirements (use `search_for_pattern`)
- Start with a strict interpretation (MUST) and relax if verification fails

### Untestable Requirements
Some requirements cannot be tested via NCT:
- Quantitative timing ("within 3 RTTs") — consider NSCT
- Implementation-internal state ("SHOULD maintain a cache")
- Performance requirements ("MUST NOT exceed bandwidth")

### Circular Dependencies
Avoid creating circular `require` chains where action A requires state set by action B, and B requires state set by A. Break cycles by identifying which action happens first in the protocol flow.

## Serena Tools

| Task | Tool |
|---|---|
| Read RFC requirements file | `read_file` |
| Search existing requirement mappings | `search_for_pattern` |
| Find how a requirement is implemented | `find_symbol`, `find_referencing_symbols` |
| Create new assertion | `replace_symbol_body`, `insert_after_symbol` |
| Verify consistency | `ivy_check` |

**IMPORTANT**: Always use panther-serena MCP tools. Never run ivy_check, ivyc, ivy_show, or ivy_to_cpp directly via Bash.
