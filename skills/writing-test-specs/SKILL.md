---
name: Writing Test Specs
description: This skill should be used when the user asks about "writing test files", "test specifications", "monitors", "assertions", "before/after clauses", "_finalize", "export actions", "test variants", "writing Ivy tests", "creating protocol tests", or mentions creating new test specifications for protocol verification in the PANTHER Ivy framework.
---

# Writing Ivy Test Specifications

## Overview

Test specifications are the verification layer of Ivy protocol models. They define which protocol actions the test mirror generates, what properties are checked, and what constitutes a passing test. Each test spec targets a specific role (client, server, MIM) and optionally focuses on specific protocol features.

## Test Specification Structure

Every test specification follows this pattern:

```ivy
#lang ivy1.7

# 1. Includes — pull in the protocol stack and entity behavior
include order
include {prot}_infer
include file
include ivy_{prot}_shim_{role}       # Shim for the role Ivy plays
include {prot}_locale
include ivy_{prot}_{role}_behavior   # Behavioral constraints

# 2. Transport parameters (optional)
include ivy_{prot}_{role}_standard_tp

# 3. Time support (optional)
include {prot}_time

# 4. Initialization — set up network, TLS, initial state
after init {
    sock := net.open(endpoint_id.{role}, {role}.ep);
    {role}.set_tls_id(0);
    var extns := tls_extensions.empty;
    extns := extns.append(make_transport_parameters);
    call tls_api.upper.create(0, false, extns);
}

# 5. Exported actions — these are generated by the test mirror
export frame.ack.handle
export frame.stream.handle
export frame.crypto.handle
export packet_event
export {role}_send_event
export tls_recv_event

# 6. Final verification
export action _finalize = {
    require is_no_error;
    require conn_total_data(the_cid) > 0;
}
```

## Key Components

### Includes
The includes establish the protocol context. Order matters — dependencies must be included before dependents. The critical includes are:
- **Shim** (`ivy_{prot}_shim_{role}`) — bridges formal model to implementation
- **Entity behavior** (`ivy_{prot}_{role}_behavior`) — encodes RFC requirements as monitors

### Initialization (`after init`)
The `after init` block runs once when the test starts. It:
- Opens network sockets for each endpoint
- Sets TLS identifiers for each participant
- Creates transport parameter extensions
- Initializes the TLS/security layer

### Exported Actions
`export` declarations tell the test mirror which actions to generate randomly. Z3/SMT solving ensures generated actions satisfy all `before` clause constraints.

Common exported actions:
- `frame.*.handle` — Frame processing events (ack, stream, crypto, etc.)
- `packet_event` — Packet transmission events
- `{role}_send_event` — Role-specific send events
- `tls_recv_event` — TLS receive events
- `send_ack_eliciting_*_packet` — Specific packet type sends

### before Clauses (Preconditions)
`before` clauses define what must be true before an action can occur:

```ivy
before packet_event(src, dst, pkt) {
    require connected(src);
    require pkt.hdr.dcid = conn_cid(the_cid);
}
```

These are defined in the behavior files, not the test spec itself. The test spec inherits them through includes.

### after Clauses (State Updates/Checks)
`after` clauses update state and check compliance after an action:

```ivy
after packet_event(src, dst, pkt) {
    conn_total_data(the_cid) := conn_total_data(the_cid) + pkt.payload_length;
    require pkt.hdr.version = negotiated_version;
}
```

These are also primarily in behavior files. Test specs can add additional `after` advice.

### _finalize() (End-State Verification)
`_finalize()` is called when the test completes. It performs heuristic end-state checks:

```ivy
export action _finalize = {
    require is_no_error;                    # No protocol errors occurred
    require conn_total_data(the_cid) > 0;   # Some data was transferred
}
```

Additional checks can be added via `after _finalize` in variant files.

## Role Isolation

### Server Tests (Ivy acts as client)
Test files: `{prot}_server_test_*.ivy`
- Ivy plays the **client** role, generates client traffic
- IUT plays the **server** role, responds to client requests
- Tests verify server compliance with spec

### Client Tests (Ivy acts as server)
Test files: `{prot}_client_test_*.ivy`
- Ivy plays the **server** role, generates server responses
- IUT plays the **client** role, initiates connections
- Tests verify client compliance with spec

### MIM Tests
Test files: `{prot}_mim_test_*.ivy`
- Ivy plays the **man-in-the-middle** role
- Intercepts and potentially modifies traffic between IUT endpoints
- Tests verify security properties under adversarial conditions

## Test Variants

Base test files define the common structure. Variant files extend them for specific scenarios:

```ivy
#lang ivy1.7
include {prot}_server_test              # Include base test

# Add weight attributes to bias generation
attribute frame.crypto.handle.weight = "5"
attribute frame.path_response.handle.weight = "5"

# Optionally export additional actions
export frame.new_connection_id.handle
export frame.retire_connection_id.handle

# Optionally add variant-specific _finalize checks
after _finalize {
    require migration_completed;
}
```

### Weight Attributes
Weight attributes bias the random action generation. Higher weights make an action more likely to be chosen:
```ivy
attribute frame.stream.handle.weight = "10"   # Strongly prefer stream frames
attribute frame.crypto.handle.weight = "5"    # Moderate crypto frame frequency
```

### Common Variant Patterns (from QUIC)
- `*_stream.ivy` — Basic stream data transfer
- `*_connection_close.ivy` — Connection termination
- `*_retry.ivy` — Retry mechanism testing
- `*_migration.ivy` — Connection migration
- `*_0rtt.ivy` — Zero-RTT early data
- `*_timeout.ivy` — Timeout handling
- `*_*_error.ivy` — Error condition testing

## Mapping RFC Requirements to Test Assertions

| RFC Keyword | Ivy Construct | Location |
|---|---|---|
| MUST | `require` in before/after | Behavior file |
| MUST NOT | `require ~(condition)` in before/after | Behavior file |
| SHOULD | Weaker assertion or logged warning | Behavior file |
| MAY | No assertion (optional behavior) | — |

Example mapping:
- RFC: "A server MUST NOT send data exceeding flow control limits"
- Ivy: `after frame.stream.handle(f) { require f.offset + f.length <= max_stream_data(f.id); }`

## Serena Tools for Test Specs

| Task | Tool |
|---|---|
| Read existing tests | `read_file`, `find_symbol` |
| Understand test structure | `get_symbols_overview` |
| Find test patterns | `search_for_pattern` |
| Create new test | `create_text_file` |
| Add variant checks | `replace_symbol_body`, `insert_after_symbol` |
| Verify test | `ivy_check` |
| Compile test | `ivy_compile` |

**IMPORTANT**: Always use panther-serena MCP tools. Never run ivy_check, ivyc, ivy_show, or ivy_to_cpp directly via Bash.

## Quick Reference: Test File Checklist

1. `#lang ivy1.7` header
2. Protocol stack includes (order, infer, file)
3. Shim include for the role Ivy plays
4. Entity behavior include
5. Transport parameters include (optional)
6. `after init` block with socket/TLS setup
7. `export` declarations for mirror-generated actions
8. `_finalize` with end-state checks
9. Weight attributes for test focus (optional)
